#!/usr/bin/zsh -x

# Assumes a working internet connection.

base=(base arch-install-scripts syslinux zsh grml-zsh-config p7zip vim git
openssh wpa_supplicant)

console=(alsa-utils base-devel syslinux arch-install-scripts bc cmake clang gdb
git gnu-netcat googlecl grml-zsh-config iotop irssi john lsof ltrace nasm
nss-mdns ntfs-3g ntp ntop nmap openssh openvpn p7zip python python-pip
python2-crypto python2-pip python2-virtualenv qemu rsync ruby screen subversion
strace scrot tcpdump tor transmission-cli unrar unzip vim w3m wget whois words
wpa_supplicant zsh)

xorg=(dmenu bless evince flashplugin gimp gitg gtk2fontsel hsetroot i3status
i3-wm mplayer pidgin pidgin-otr slim slock surf transmission-gtk xchat xorg
xorg-xinit xpdf xterm firefox chromium ttf-freefont)

# ttf-bitstream-vera ttf-dejavu ttf-freefont ttf-liberation

# No support for AUR or multilib just yet...
# aur=(rxvt-unicode-patched metasploit volatility-svn wireshark-cli
# wireshark-gtk sqlmap gist paxctl vim-gist snort sublime-text tlp sup hub jdk
# intellij-idea-community-edition rar)
#
# opengl=(mesa-libgl glu glxinfo glxgears glew glm glfw)
#
# multilib=(multilib-devel skype xf86-video-intel intel-dri lib32-intel-dri
# libtxc_dxtn lib32-libtxc_dxtn steam)

cd $(dirname $0)

error() {
  ! echo Error: $@
}

check_running_root() {
  [[ $(id -u) == 0 ]] || error "Run this script as root."
}

parse_options() {
  export ENCRYPTION=yes
  unset RAMFS
  export HOSTNAME=roofix
  export NEW_USER=user
  export LANG=en_AU.UTF-8
  export KEYMAP=dvorak
  export TZ=Australia/Sydney
  while getopts ':nru:h:l:k:t:p:' opt; do
    case $opt in
      h) HOSTNAME=$OPTARG ;;
      n) unset ENCRYPTION ;;
      r) RAMFS=1 ;;
      u) NEW_USER=$OPTARG ;;
      l) LANG=$OPTARG ;;
      k) KEYMAP=$OPTARG ;;
      t) TZ=$OPTARG ;;
      p) PACKAGES=("${(s/,/)OPTARG}") ;;
      ?) error "Unknown option $OPTARG" ;;
    esac
  done
  shift $((OPTIND-1))
  export DEVICE=$1
  [[ -n $DEVICE ]] || error "No device provided."
  ! mount | grep -q $DEVICE || error "$DEVICE is mounted."
  if [[ ! -e $DEVICE || -f $DEVICE ]]; then
    echo "$DEVICE does not exist or is a regular file. Creating a 16G image file."
    dd of=$DEVICE bs=1 seek=16G count=0
  fi
}

setup_loopback() {
  modprobe -r loop || true
  modprobe loop max_part=15
  LOOPBACK=$(losetup --show -f $DEVICE)
}

cleanup_loopback() {
  losetup -d $LOOPBACK
}

get_passphrase() {
  set +x
  stty -echo
  passphrase='a'
  passphrase2='b'
  while [[ $passphrase != $passphrase2 ]]; do
    echo -n "encryption passphrase: "
    read passphrase
    echo -n "again: "
    read passphrase2
    if [[ $passphrase != $passphrase2 ]]; then
      echo "didn't match, try again"
    fi
  done
  stty echo
  set -x
}

map_root_device() {
  if [[ -n $ENCRYPTION ]]; then
    set +x
    echo -n $passphrase | cryptsetup luksOpen ${LOOPBACK}p2 $CRYPTNAME -d -
    set -x
    ROOT_DEVICE=/dev/mapper/$CRYPTNAME
  else
    ROOT_DEVICE=${LOOPBACK}p2
  fi
}

unmap_root_device() {
  if [[ -n $ENCRYPTION ]]; then
    cryptsetup luksClose $CRYPTNAME
  fi
}

setup_encryption() {
  if [[ -n $ENCRYPTION ]]; then
    CRYPTNAME=root$RANDOM
    get_passphrase
    set +x
    echo -n $passphrase | cryptsetup -c aes-cbc-essiv:sha256 --use-random -y luksFormat ${LOOPBACK}p2 -d -
    set -x
  fi
}

create_partitions() {
  echo -e "o\nn\np\n1\n\n+32M\nn\np\n2\n\n\na\n1\nw" | fdisk $LOOPBACK
  # cycle this to 
  cleanup_loopback
  setup_loopback
  BOOT_DEVICE=${LOOPBACK}p1
}

create_filesystems() {
  mkfs.ext4 $BOOT_DEVICE
  mkfs.ext4 $ROOT_DEVICE
}

mount_filesystems() {
  TARGET=$(mktemp -d)
  mount $ROOT_DEVICE $TARGET
  mkdir -p $TARGET/boot
  mount $BOOT_DEVICE $TARGET/boot
}

unmount_filesystems() {
  umount $TARGET/boot
  umount $TARGET
  rmdir $TARGET
}

install_packages() {
  for package_group in base $PACKAGES; do
    pacstrap -c -C pacstrap.conf $TARGET ${(P)package_group}
  done
}

disk_setup() {
  setup_loopback
  create_partitions
  setup_encryption
  map_root_device
  create_filesystems
  mount_filesystems
}

clean_up() {
  unmount_filesystems
  unmap_root_device
  cleanup_loopback
}

TRAPZERR() {
  clean_up 2> /dev/null
  exit
}

check_running_root
parse_options $@
disk_setup
install_packages
clean_up
